<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCM Audio Recorder - CloudDrive</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="styles.css">
    <style>
        @keyframes pulseDot { 
            0%{transform:scale(1);opacity:1} 
            50%{transform:scale(1.35);opacity:.65} 
            100%{transform:scale(1);opacity:1} 
        }
        .pulse-dot { animation: pulseDot 1s ease-in-out infinite; }
        .ctrl-btn { 
            display:inline-flex; 
            align-items:center; 
            gap:.5rem; 
            padding:.75rem 1rem; 
            border-radius:.75rem; 
            font-weight:600; 
            font-size:.875rem; 
            transition:all .15s; 
        }
        .ctrl-disabled { 
            background:#cbd5e1; 
            color:#475569; 
            opacity:.9; 
            cursor:not-allowed; 
        }
        .recording-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 0.5rem;
            transition: all 0.2s;
        }
        .recording-item:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .upload-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.125rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 500;
        }
        .upload-success { background: #dcfce7; color: #16a34a; }
        .upload-pending { background: #fef3c7; color: #d97706; }
        .upload-failed { background: #fee2e2; color: #dc2626; }
        .upload-uploading { background: #dbeafe; color: #2563eb; }
        
        /* Enhanced player and chunk styles */
        #unifiedPlayer { transition: all 0.3s ease; }
        .chunk-item { transition: all 0.2s ease; position: relative; }
        .chunk-item.playing {
            background: linear-gradient(to right, #EFF6FF, #DBEAFE);
            border-color: #3B82F6;
        }
        .chunk-item.hidden { display: none !important; }
        .chunk-indicator {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 70%;
            background: #3B82F6;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .chunk-item.playing .chunk-indicator {
            opacity: 1;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Mobile optimizations */
        @media (max-width: 640px) {
            #unifiedPlayer { padding: 12px; }
            #mainPlayPause { width: 40px; height: 40px; }
            .chunk-item { padding: 10px; }
            .chunk-play-btn { width: 32px; height: 32px; }
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-900">
    <main class="max-w-6xl mx-auto p-6 space-y-6">
        <!-- Header with auth status -->
        <header class="flex items-center justify-between border-b pb-4">
            <div>
                <h1 class="text-2xl font-bold">PCM Audio Recorder</h1>
                <p class="text-sm text-slate-600 mt-1">High-quality WAV recording with S3 upload</p>
            </div>
            <div class="flex items-center gap-4">
                <div id="authStatus" class="text-sm">
                    <span class="text-slate-500">User:</span>
                    <span id="userEmail" class="font-medium">Loading...</span>
                </div>
                <a href="/files.html" class="ctrl-btn bg-slate-600 text-white hover:bg-slate-700">
                    üìÅ Files
                </a>
                <a href="/" class="ctrl-btn bg-slate-100 hover:bg-slate-200">
                    ‚Üê Dashboard
                </a>
            </div>
        </header>

        <!-- Main recording interface -->
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <!-- Recording Controls -->
            <section class="bg-white rounded-xl shadow-sm border p-6">
                <h2 class="text-lg font-semibold mb-4 flex items-center gap-2">
                    <span>üéôÔ∏è</span> Recording Controls
                </h2>
                
                <!-- Main controls -->
                <div class="flex items-center gap-3 mb-6">
                    <button id="btnStart" class="ctrl-btn text-white bg-emerald-600 hover:bg-emerald-700">
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        <span>Start</span>
                    </button>
                    
                    <button id="btnPause" class="ctrl-btn ctrl-disabled" disabled>
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M7 5h4v14H7zM13 5h4v14h-4z"/>
                        </svg>
                        <span>Pause</span>
                    </button>
                    
                    <button id="btnResume" class="ctrl-btn ctrl-disabled" disabled>
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        <span>Resume</span>
                    </button>
                    
                    <button id="btnStop" class="ctrl-btn ctrl-disabled" disabled>
                        <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                            <rect x="6" y="6" width="12" height="12" rx="2"/>
                        </svg>
                        <span>Stop</span>
                    </button>
                </div>

                <!-- Status display -->
                <div class="bg-slate-50 rounded-lg p-4 mb-6">
                    <div class="flex items-center justify-between mb-3">
                        <div id="stateChip" class="flex items-center gap-2 px-3 py-1.5 rounded-full bg-slate-100 border">
                            <span id="stateIcon">‚èπÔ∏è</span>
                            <span id="stateLabel" class="text-sm font-medium">Ready</span>
                        </div>
                        <div id="timer" class="font-mono text-lg font-bold">00:00</div>
                    </div>
                    
                    <!-- Level meter -->
                    <div class="space-y-2">
                        <div class="text-xs text-slate-500">Audio Level</div>
                        <div class="h-3 bg-slate-200 rounded-full overflow-hidden">
                            <div id="liveLevelBar" class="h-full bg-emerald-500 transition-[width] duration-75" style="width:0%"></div>
                        </div>
                        <div id="liveLevelText" class="text-xs text-slate-500">RMS: 0.00 ‚Ä¢ Peak: 0.00</div>
                    </div>
                </div>

                <!-- Chunk duration control -->
                <div class="space-y-3">
                    <div class="flex items-center justify-between">
                        <label class="text-sm font-medium">Chunk Duration</label>
                        <span id="chunkValue" class="text-sm font-mono bg-slate-100 px-2 py-1 rounded">10s</span>
                    </div>
                    <input id="chunkSeconds" type="range" min="5" max="300" step="5" value="10" 
                           class="w-full accent-emerald-600">
                    <div class="flex justify-between text-xs text-slate-500">
                        <span>5 sec</span>
                        <span>5 min</span>
                    </div>
                </div>

                <!-- Session stats -->
                <div class="mt-6 pt-6 border-t grid grid-cols-2 gap-4 text-sm">
                    <div>
                        <div class="text-slate-500">Session ID</div>
                        <div id="sessionId" class="font-mono text-xs truncate">-</div>
                    </div>
                    <div>
                        <div class="text-slate-500">Duration</div>
                        <div id="sessionDuration" class="font-semibold">00:00</div>
                    </div>
                    <div>
                        <div class="text-slate-500">Chunks</div>
                        <div id="sessionChunks" class="font-semibold">0</div>
                    </div>
                    <div>
                        <div class="text-slate-500">Total Size</div>
                        <div id="sessionSize" class="font-semibold">0 MB</div>
                    </div>
                </div>
            </section>

            <!-- Recordings List -->
            <section class="bg-white rounded-xl shadow-sm border p-6">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-lg font-semibold flex items-center gap-2">
                        <span>üìº</span> Session Chunks
                        <span id="chunkCount" class="text-sm bg-slate-100 px-2 py-1 rounded-full">0</span>
                    </h2>
                    <div class="flex gap-2">
                        <button id="btnShowAll" class="text-sm text-blue-600 hover:text-blue-700 hidden">
                            Show All
                        </button>
                        <button id="btnShowLess" class="text-sm text-gray-600 hover:text-gray-700 hidden">
                            Show Recent
                        </button>
                        <button id="btnClearAll" class="text-sm text-red-600 hover:text-red-700">
                            Clear All
                        </button>
                    </div>
                </div>
                
                <!-- Unified Player Controls -->
                <div id="unifiedPlayer" class="hidden mb-4 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border border-blue-200">
                    <div class="flex items-center gap-4 mb-3">
                        <!-- Main Play/Pause -->
                        <button id="mainPlayPause" class="w-12 h-12 bg-blue-600 text-white rounded-full hover:bg-blue-700 flex items-center justify-center transition-all shadow-lg">
                            <svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor">
                                <path id="playIcon" d="M8 5v14l11-7z"/>
                                <path id="pauseIcon" class="hidden" d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
                            </svg>
                        </button>
                        
                        <!-- Track controls -->
                        <div class="flex items-center gap-2">
                            <button id="prevChunk" class="text-blue-600 hover:text-blue-700 disabled:opacity-50 disabled:cursor-not-allowed">
                                <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
                                </svg>
                            </button>
                            <button id="nextChunk" class="text-blue-600 hover:text-blue-700 disabled:opacity-50 disabled:cursor-not-allowed">
                                <svg class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
                                </svg>
                            </button>
                        </div>
                        
                        <!-- Current track info -->
                        <div class="flex-1">
                            <div class="text-sm font-medium text-gray-700" id="currentTrackInfo">Ready to play</div>
                            <div class="text-xs text-gray-500" id="currentTrackStatus">0 chunks available</div>
                        </div>
                        
                        <!-- Volume control (hidden on mobile) -->
                        <div class="hidden sm:flex items-center gap-2">
                            <svg class="w-4 h-4 text-gray-500" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M3 9v6h4l5 5V4L7 9H3z"/>
                            </svg>
                            <input type="range" id="volumeControl" min="0" max="100" value="80" class="w-20">
                        </div>
                    </div>
                    
                    <!-- Progress bar -->
                    <div class="relative">
                        <div class="w-full bg-gray-200 rounded-full h-2 cursor-pointer" id="progressBar">
                            <div id="progressFill" class="bg-blue-600 h-2 rounded-full transition-all relative" style="width: 0%">
                                <div class="absolute right-0 top-1/2 transform -translate-y-1/2 w-3 h-3 bg-white border-2 border-blue-600 rounded-full shadow-sm"></div>
                            </div>
                        </div>
                        <div class="flex justify-between text-xs text-gray-500 mt-1">
                            <span id="currentTime">0:00</span>
                            <span id="totalTime">0:00</span>
                        </div>
                    </div>
                </div>
                
                <div id="recordingsList" class="space-y-2 max-h-[400px] overflow-y-auto">
                    <div id="emptyState" class="text-center text-slate-400 py-8">
                        No recordings yet. Click "Start" to begin recording.
                    </div>
                </div>
            </section>
        </div>

        <!-- Debug/Info Panel -->
        <div class="bg-white rounded-xl shadow-sm border p-4">
            <details>
                <summary class="cursor-pointer font-medium">Debug Information</summary>
                <div id="debugLog" class="mt-3 font-mono text-xs space-y-1 max-h-40 overflow-y-auto">
                </div>
            </details>
        </div>
    </main>

    <script type="module">
        // Configuration
        const config = {
            userPoolId: 'us-east-2_Mjk5creBj',
            userPoolClientId: 'ddjkepnksfmpkrjuojilaau2b',
            identityPoolId: 'us-east-2:68194838-5526-4510-9673-af2c07e8ed44',
            region: 'us-east-2',
            apiUrl: 'https://d2vkipfwau0424.cloudfront.net/api/data',
            audioApiUrl: 'https://d2vkipfwau0424.cloudfront.net/api/audio',
            appUrl: 'https://d2vkipfwau0424.cloudfront.net'
        };

        // Debug logging
        const log = (message) => {
            console.log(message);
            const timestamp = new Date().toLocaleTimeString();
            const debugLog = document.getElementById('debugLog');
            if (debugLog) {
                const entry = document.createElement('div');
                entry.textContent = `${timestamp}: ${message}`;
                debugLog.appendChild(entry);
                debugLog.scrollTop = debugLog.scrollHeight;
            }
        };

        // Authentication
        const getAuthToken = () => localStorage.getItem('id_token');
        
        const getUserFromToken = () => {
            const token = getAuthToken();
            if (!token) return null;
            
            try {
                const payload = JSON.parse(atob(token.split('.')[1]));
                return {
                    email: payload.email,
                    userId: payload.sub,
                    name: payload.given_name || payload.email
                };
            } catch (error) {
                log('Error parsing token: ' + error.message);
                return null;
            }
        };

        // Check auth on load
        const user = getUserFromToken();
        if (!user) {
            window.location.href = '/';
        } else {
            document.getElementById('userEmail').textContent = user.email;
            log(`Authenticated as: ${user.email}`);
        }

        // Import modules
        import { createRecorderBox } from './js/recorder-box.js';
        import { createS3Storage } from './js/storage-s3.js';

        // Initialize recorder
        let recorder = null;
        let storage = null;
        let currentSessionId = null;
        const recordings = [];

        async function initializeRecorder() {
            try {
                log('Starting recorder initialization...');
                
                // Check if modules are available
                if (typeof createS3Storage === 'undefined') {
                    log('ERROR: createS3Storage module not loaded');
                    return;
                }
                if (typeof createRecorderBox === 'undefined') {
                    log('ERROR: createRecorderBox module not loaded');
                    return;
                }
                
                // Create S3 storage adapter
                log('Creating S3 storage adapter...');
                storage = await createS3Storage({
                    apiUrl: config.audioApiUrl,
                    getAuthToken: getAuthToken,
                    getUserId: () => user?.userId,
                    enableLocalBackup: true
                });
                log('S3 storage created successfully');

                // Create recorder with S3 storage
                log('Creating recorder...');
                recorder = await createRecorderBox({
                    storage: storage,
                    chunkSeconds: parseInt(document.getElementById('chunkSeconds').value),
                    channels: 1
                });
                log('Recorder created successfully');

                // Setup event listeners
                recorder.on('status', ({ status }) => {
                    updateUIState(status);
                    log(`Status: ${status}`);
                });

                recorder.on('meter', ({ rms, peak }) => {
                    const percent = Math.min(100, peak * 100);
                    document.getElementById('liveLevelBar').style.width = `${percent}%`;
                    document.getElementById('liveLevelText').textContent = 
                        `RMS: ${rms.toFixed(2)} ‚Ä¢ Peak: ${peak.toFixed(2)}`;
                });

                recorder.on('chunk', ({ size, index, wavBlob, uploaded }) => {
                    log(`Chunk ${index} created: ${(size/1024).toFixed(1)} KB, uploaded: ${uploaded}`);
                    // Create a blob URL for playback if we have the wav blob
                    const blobUrl = wavBlob ? URL.createObjectURL(wavBlob) : null;
                    if (blobUrl) {
                        log(`Created blob URL for chunk ${index}: ${blobUrl.substring(0, 50)}...`);
                    } else {
                        log(`WARNING: No audio blob for chunk ${index}`);
                    }
                    addChunkToList(index, size, blobUrl, wavBlob);
                });

                recorder.on('stats', ({ durationMs, chunkCount, bytes }) => {
                    document.getElementById('sessionDuration').textContent = formatTime(Math.floor(durationMs / 1000));
                    document.getElementById('sessionChunks').textContent = chunkCount;
                    document.getElementById('sessionSize').textContent = `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
                });

                log('Recorder initialized successfully');
            } catch (error) {
                log(`Failed to initialize recorder: ${error.message}`);
                alert('Failed to initialize audio recorder. Please check permissions.');
            }
        }

        // UI State Management
        function updateUIState(status) {
            const stateLabel = document.getElementById('stateLabel');
            const stateIcon = document.getElementById('stateIcon');
            const btnStart = document.getElementById('btnStart');
            const btnPause = document.getElementById('btnPause');
            const btnResume = document.getElementById('btnResume');
            const btnStop = document.getElementById('btnStop');
            
            // Reset all buttons
            [btnStart, btnPause, btnResume, btnStop].forEach(btn => {
                btn.disabled = true;
                btn.classList.add('ctrl-disabled');
            });

            switch(status) {
                case 'idle':
                    stateLabel.textContent = 'Ready';
                    stateIcon.textContent = '‚èπÔ∏è';
                    btnStart.disabled = false;
                    btnStart.classList.remove('ctrl-disabled');
                    break;
                case 'recording':
                    stateLabel.textContent = 'Recording';
                    stateIcon.innerHTML = '<span class="pulse-dot">üî¥</span>';
                    btnPause.disabled = false;
                    btnPause.classList.remove('ctrl-disabled');
                    btnStop.disabled = false;
                    btnStop.classList.remove('ctrl-disabled');
                    break;
                case 'paused':
                    stateLabel.textContent = 'Paused';
                    stateIcon.textContent = '‚è∏Ô∏è';
                    btnResume.disabled = false;
                    btnResume.classList.remove('ctrl-disabled');
                    btnStop.disabled = false;
                    btnStop.classList.remove('ctrl-disabled');
                    break;
            }
        }

        // Player state management
        let currentAudio = null;
        let currentChunkIndex = -1;
        let isPlaying = false;
        let showAllChunks = false;
        const MAX_VISIBLE_CHUNKS = 3;
        
        // Format time helper
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Update chunk visibility
        function updateChunkVisibility() {
            const chunkElements = document.querySelectorAll('.chunk-item');
            const totalChunks = recordings.length;
            
            if (totalChunks <= MAX_VISIBLE_CHUNKS) {
                // Show all if we have few chunks
                chunkElements.forEach(el => el.classList.remove('hidden'));
                document.getElementById('btnShowAll').classList.add('hidden');
                document.getElementById('btnShowLess').classList.add('hidden');
            } else {
                // Show/hide based on state
                chunkElements.forEach((el, index) => {
                    if (showAllChunks) {
                        el.classList.remove('hidden');
                    } else {
                        // Show only the last MAX_VISIBLE_CHUNKS
                        const isRecent = index >= (totalChunks - MAX_VISIBLE_CHUNKS);
                        el.classList.toggle('hidden', !isRecent);
                    }
                });
                
                // Update buttons
                document.getElementById('btnShowAll').classList.toggle('hidden', showAllChunks);
                document.getElementById('btnShowLess').classList.toggle('hidden', !showAllChunks);
                document.getElementById('btnShowAll').textContent = `Show All (${totalChunks})`;
            }
            
            // Update chunk count
            document.getElementById('chunkCount').textContent = totalChunks;
            
            // Show/hide player
            const player = document.getElementById('unifiedPlayer');
            if (totalChunks > 0) {
                player.classList.remove('hidden');
                document.getElementById('currentTrackStatus').textContent = `${totalChunks} chunk${totalChunks !== 1 ? 's' : ''} available`;
            } else {
                player.classList.add('hidden');
            }
        }
        
        // Play specific chunk (make it global for onclick handlers)
        window.playChunk = function(index) {
            if (index < 0 || index >= recordings.length) {
                log(`Cannot play chunk ${index}: out of range`);
                return;
            }
            
            const recording = recordings[index];
            
            if (!recording.url) {
                log(`Cannot play chunk ${index}: no audio URL available`);
                alert(`Chunk ${index + 1} audio is not available yet. It may still be uploading.`);
                return;
            }
            
            log(`Playing chunk ${index}: ${recording.url.substring(0, 50)}...`);
            
            // Stop current audio if playing
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.src = '';  // Clean up properly
                currentAudio = null;
            }
            
            currentChunkIndex = index;
            
            // Create audio element
            try {
                currentAudio = new Audio(recording.url);
                currentAudio.volume = document.getElementById('volumeControl').value / 100;
            
            // Update UI
            document.getElementById('currentTrackInfo').textContent = `Playing Chunk ${index + 1}`;
            document.getElementById('playIcon').classList.add('hidden');
            document.getElementById('pauseIcon').classList.remove('hidden');
            isPlaying = true;
            
            // Update chunk items
            document.querySelectorAll('.chunk-item').forEach((el, i) => {
                el.classList.toggle('playing', i === index);
            });
            
            // Update progress
            currentAudio.addEventListener('timeupdate', () => {
                const progress = (currentAudio.currentTime / currentAudio.duration) * 100;
                document.getElementById('progressFill').style.width = `${progress}%`;
                document.getElementById('currentTime').textContent = formatTime(currentAudio.currentTime);
                document.getElementById('totalTime').textContent = formatTime(currentAudio.duration || 0);
            });
            
            // Handle end of chunk
            currentAudio.addEventListener('ended', () => {
                // Auto-play next chunk if available
                if (currentChunkIndex < recordings.length - 1) {
                    playChunk(currentChunkIndex + 1);
                } else {
                    // End of all chunks
                    stopPlayback();
                }
            });
            
            // Handle errors
            currentAudio.addEventListener('error', (e) => {
                log(`Error playing chunk ${index + 1}: ${e.message}`);
                stopPlayback();
            });
            
            currentAudio.play().catch(e => {
                log(`Failed to play chunk: ${e.message}`);
                stopPlayback();
            });
            
            // Update nav buttons
            document.getElementById('prevChunk').disabled = index === 0;
            document.getElementById('nextChunk').disabled = index === recordings.length - 1;
            
            } catch (error) {
                log(`Error creating audio element: ${error.message}`);
                alert(`Failed to play audio: ${error.message}`);
                stopPlayback();
            }
        }
        
        // Stop playback
        function stopPlayback() {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            
            isPlaying = false;
            currentChunkIndex = -1;
            
            // Update UI
            document.getElementById('playIcon').classList.remove('hidden');
            document.getElementById('pauseIcon').classList.add('hidden');
            document.getElementById('currentTrackInfo').textContent = 'Ready to play';
            document.getElementById('progressFill').style.width = '0%';
            document.getElementById('currentTime').textContent = '0:00';
            document.getElementById('totalTime').textContent = '0:00';
            
            // Remove playing state from chunks
            document.querySelectorAll('.chunk-item').forEach(el => {
                el.classList.remove('playing');
            });
        }
        
        // Player controls
        document.getElementById('mainPlayPause').addEventListener('click', () => {
            if (isPlaying && currentAudio) {
                // Pause
                currentAudio.pause();
                isPlaying = false;
                document.getElementById('playIcon').classList.remove('hidden');
                document.getElementById('pauseIcon').classList.add('hidden');
            } else if (!isPlaying && currentAudio) {
                // Resume
                currentAudio.play();
                isPlaying = true;
                document.getElementById('playIcon').classList.add('hidden');
                document.getElementById('pauseIcon').classList.remove('hidden');
            } else {
                // Start playing from beginning
                playChunk(0);
            }
        });
        
        document.getElementById('prevChunk').addEventListener('click', () => {
            if (currentChunkIndex > 0) {
                playChunk(currentChunkIndex - 1);
            }
        });
        
        document.getElementById('nextChunk').addEventListener('click', () => {
            if (currentChunkIndex < recordings.length - 1) {
                playChunk(currentChunkIndex + 1);
            }
        });
        
        // Volume control
        document.getElementById('volumeControl').addEventListener('input', (e) => {
            if (currentAudio) {
                currentAudio.volume = e.target.value / 100;
            }
        });
        
        // Progress bar click to seek
        document.getElementById('progressBar').addEventListener('click', (e) => {
            if (!currentAudio) return;
            
            const rect = e.currentTarget.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            currentAudio.currentTime = percent * currentAudio.duration;
        });
        
        // Show/hide controls
        document.getElementById('btnShowAll').addEventListener('click', () => {
            showAllChunks = true;
            updateChunkVisibility();
        });
        
        document.getElementById('btnShowLess').addEventListener('click', () => {
            showAllChunks = false;
            updateChunkVisibility();
        });

        // Recording controls
        document.getElementById('btnStart').addEventListener('click', async () => {
            try {
                if (!recorder) {
                    log('ERROR: Recorder not initialized, attempting to initialize...');
                    await initializeRecorder();
                    if (!recorder) {
                        alert('Failed to initialize recorder. Please refresh the page and try again.');
                        return;
                    }
                }
                
                currentSessionId = `session-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`;
                document.getElementById('sessionId').textContent = currentSessionId;
                document.getElementById('recordingsList').innerHTML = '';
                recordings.length = 0;
                updateChunkVisibility();
                
                const result = await recorder.start();
                if (result && result.recordingId) {
                    currentSessionId = result.recordingId;
                    document.getElementById('sessionId').textContent = currentSessionId;
                }
            } catch (error) {
                log(`ERROR starting recording: ${error.message}`);
                alert(`Failed to start recording: ${error.message}`);
            }
        });

        document.getElementById('btnPause').addEventListener('click', () => {
            recorder.pause();
        });

        document.getElementById('btnResume').addEventListener('click', () => {
            recorder.resume();
        });

        document.getElementById('btnStop').addEventListener('click', () => {
            recorder.stop();
            currentSessionId = null;
        });

        // Chunk duration control
        const chunkSlider = document.getElementById('chunkSeconds');
        const chunkValue = document.getElementById('chunkValue');
        
        chunkSlider.addEventListener('input', (e) => {
            const seconds = parseInt(e.target.value);
            if (seconds >= 60) {
                chunkValue.textContent = `${Math.floor(seconds/60)}m ${seconds%60}s`;
            } else {
                chunkValue.textContent = `${seconds}s`;
            }
        });

        // Timer
        let timerInterval = null;
        let timerSeconds = 0;
        
        function startTimer() {
            timerSeconds = 0;
            timerInterval = setInterval(() => {
                timerSeconds++;
                document.getElementById('timer').textContent = formatTime(timerSeconds);
            }, 1000);
        }
        
        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            timerSeconds = 0;
            document.getElementById('timer').textContent = '00:00';
        }

        // Helper functions (formatTime already defined above)

        function addChunkToList(index, size, blobUrl, audioBlob) {
            const recording = {
                id: `${currentSessionId}-chunk-${index}`,
                index: index,
                size: size,
                timestamp: new Date(),
                status: 'uploading',
                url: blobUrl,  // Store the blob URL for playback
                blob: audioBlob,  // Store the actual blob
                duration: 0  // Will be updated when we can read it
            };
            
            // Try to get duration if we have an audio blob
            if (audioBlob && blobUrl) {
                const tempAudio = new Audio(blobUrl);
                tempAudio.addEventListener('loadedmetadata', () => {
                    recording.duration = Math.round(tempAudio.duration);
                    renderRecordingsList();
                });
            }
            
            recordings.push(recording);
            renderRecordingsList();
            
            // Update status when upload completes
            setTimeout(() => {
                recording.status = 'uploaded';
                renderRecordingsList();
            }, 2000);
        }

        function renderRecordingsList() {
            const container = document.getElementById('recordingsList');
            
            if (recordings.length === 0) {
                container.innerHTML = `
                    <div id="emptyState" class="text-center text-slate-400 py-8">
                        No recordings yet. Click "Start" to begin recording.
                    </div>
                `;
                document.getElementById('unifiedPlayer').classList.add('hidden');
                return;
            }
            
            container.innerHTML = recordings.map((rec, index) => `
                <div class="chunk-item relative p-3 bg-gray-50 rounded-lg border border-gray-200 transition-all hover:bg-gray-100" data-index="${index}">
                    <div class="chunk-indicator"></div>
                    <div class="flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <button class="chunk-play-btn w-8 h-8 bg-blue-500 text-white rounded-full hover:bg-blue-600 flex items-center justify-center text-sm" onclick="playChunk(${index})">
                                ‚ñ∂
                            </button>
                            <div>
                                <div class="font-medium text-sm">Chunk ${rec.index + 1}</div>
                                <div class="text-xs text-slate-500">
                                    ${rec.timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' })} ‚Ä¢ ${rec.duration || '---'}s ‚Ä¢ ${(rec.size/1024).toFixed(1)} KB
                                </div>
                            </div>
                        </div>
                        <div class="upload-badge ${getUploadClass(rec.status)}">
                            ${getUploadIcon(rec.status)} ${rec.status}
                        </div>
                    </div>
                </div>
            `).join('');
            
            // Update visibility and player
            updateChunkVisibility();
        }

        function getUploadClass(status) {
            switch(status) {
                case 'uploaded': return 'upload-success';
                case 'uploading': return 'upload-uploading';
                case 'failed': return 'upload-failed';
                default: return 'upload-pending';
            }
        }

        function getUploadIcon(status) {
            switch(status) {
                case 'uploaded': return '‚úì';
                case 'uploading': return '‚è≥';
                case 'failed': return '‚úó';
                default: return '‚Ä¢';
            }
        }

        // Clear all recordings
        document.getElementById('btnClearAll').addEventListener('click', () => {
            if (confirm('Clear all recordings from this session?')) {
                recordings.length = 0;
                renderRecordingsList();
                log('Cleared all recordings');
            }
        });

        // Update timer when recording state changes
        recorder?.on('status', ({ status }) => {
            if (status === 'recording') {
                startTimer();
            } else if (status === 'idle') {
                stopTimer();
            }
        });

        // Initialize on page load
        initializeRecorder();
    </script>
</body>
</html>